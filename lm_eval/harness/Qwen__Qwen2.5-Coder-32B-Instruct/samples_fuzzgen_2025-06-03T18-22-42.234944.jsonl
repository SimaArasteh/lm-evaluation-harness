{"doc_id": 0, "doc": {"id": "func_0", "function_body": "size_t fz_bidi_resolve_explicit(fz_bidi_level level, fz_bidi_chartype dir, fz_bidi_chartype *pcls, fz_bidi_level *plevel, size_t cch,\n\t\t\t\tfz_bidi_level n_nest)\n{\n\tsize_t ich;\n\n\t// always called with a valid nesting level\n\t// nesting levels are != embedding levels\n\tint nLastValid = n_nest;\n\n\t// check input values\n\tassert(n_nest >= 0 && level >= 0 && level <= BIDI_LEVEL_MAX);\n\n\t// process the text\n\tfor (ich = 0; ich < cch; ich++)\n\t{\n\t\tfz_bidi_chartype cls = pcls[ich];\n\t\tswitch (cls)\n\t\t{\n\t\tcase BDI_LRO:\n\t\tcase BDI_LRE:\n\t\t\tn_nest++;\n\t\t\tif (greater_even(level) <= BIDI_LEVEL_MAX)\n\t\t\t{\n\t\t\t\tplevel[ich] = greater_even(level);\n\t\t\t\tpcls[ich] = BDI_BN;\n\t\t\t\tich += fz_bidi_resolve_explicit(plevel[ich], (cls == BDI_LRE ? BDI_N : BDI_L),\n\t\t\t\t\t\t\t&pcls[ich+1], &plevel[ich+1],\n\t\t\t\t\t\t\t cch - (ich+1), n_nest);\n\t\t\t\tn_nest--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcls = pcls[ich] = BDI_BN;\n\t\t\tbreak;\n\n\t\tcase BDI_RLO:\n\t\tcase BDI_RLE:\n\t\t\tn_nest++;\n\t\t\tif (greater_odd(level) <= BIDI_LEVEL_MAX)\n\t\t\t{\n\t\t\t\tplevel[ich] = greater_odd(level);\n\t\t\t\tpcls[ich] = BDI_BN;\n\t\t\t\tich += fz_bidi_resolve_explicit(plevel[ich], (cls == BDI_RLE ? BDI_N : BDI_R),\n\t\t\t\t\t\t\t\t&pcls[ich+1], &plevel[ich+1],\n\t\t\t\t\t\t\t\t cch - (ich+1), n_nest);\n\t\t\t\tn_nest--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcls = pcls[ich] = BDI_BN;\n\t\t\tbreak;\n\n\t\tcase BDI_PDF:\n\t\t\tcls = pcls[ich] = BDI_BN;\n\t\t\tif (n_nest)\n\t\t\t{\n\t\t\t\tif (nLastValid < n_nest)\n\t\t\t\t{\n\t\t\t\t\tn_nest--;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcch = ich; // break the loop, but complete body\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t// Apply the override\n\t\tif (dir != BDI_N)\n\t\t{\n\t\t\tcls = dir;\n\t\t}\n\t\tplevel[ich] = level;\n\t\tif (pcls[ich] != BDI_BN)\n\t\t\tpcls[ich] = cls;\n\t}\n\n\treturn ich;\n}", "instruction": "write a libfuzzer style fuzzing harness for this function", "expected_output": ""}, "target": "", "arguments": {"gen_args_0": {"arg_0": "write a libfuzzer style fuzzing harness for this function\nsize_t fz_bidi_resolve_explicit(fz_bidi_level level, fz_bidi_chartype dir, fz_bidi_chartype *pcls, fz_bidi_level *plevel, size_t cch,\n\t\t\t\tfz_bidi_level n_nest)\n{\n\tsize_t ich;\n\n\t// always called with a valid nesting level\n\t// nesting levels are != embedding levels\n\tint nLastValid = n_nest;\n\n\t// check input values\n\tassert(n_nest >= 0 && level >= 0 && level <= BIDI_LEVEL_MAX);\n\n\t// process the text\n\tfor (ich = 0; ich < cch; ich++)\n\t{\n\t\tfz_bidi_chartype cls = pcls[ich];\n\t\tswitch (cls)\n\t\t{\n\t\tcase BDI_LRO:\n\t\tcase BDI_LRE:\n\t\t\tn_nest++;\n\t\t\tif (greater_even(level) <= BIDI_LEVEL_MAX)\n\t\t\t{\n\t\t\t\tplevel[ich] = greater_even(level);\n\t\t\t\tpcls[ich] = BDI_BN;\n\t\t\t\tich += fz_bidi_resolve_explicit(plevel[ich], (cls == BDI_LRE ? BDI_N : BDI_L),\n\t\t\t\t\t\t\t&pcls[ich+1], &plevel[ich+1],\n\t\t\t\t\t\t\t cch - (ich+1), n_nest);\n\t\t\t\tn_nest--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcls = pcls[ich] = BDI_BN;\n\t\t\tbreak;\n\n\t\tcase BDI_RLO:\n\t\tcase BDI_RLE:\n\t\t\tn_nest++;\n\t\t\tif (greater_odd(level) <= BIDI_LEVEL_MAX)\n\t\t\t{\n\t\t\t\tplevel[ich] = greater_odd(level);\n\t\t\t\tpcls[ich] = BDI_BN;\n\t\t\t\tich += fz_bidi_resolve_explicit(plevel[ich], (cls == BDI_RLE ? BDI_N : BDI_R),\n\t\t\t\t\t\t\t\t&pcls[ich+1], &plevel[ich+1],\n\t\t\t\t\t\t\t\t cch - (ich+1), n_nest);\n\t\t\t\tn_nest--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcls = pcls[ich] = BDI_BN;\n\t\t\tbreak;\n\n\t\tcase BDI_PDF:\n\t\t\tcls = pcls[ich] = BDI_BN;\n\t\t\tif (n_nest)\n\t\t\t{\n\t\t\t\tif (nLastValid < n_nest)\n\t\t\t\t{\n\t\t\t\t\tn_nest--;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcch = ich; // break the loop, but complete body\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t// Apply the override\n\t\tif (dir != BDI_N)\n\t\t{\n\t\t\tcls = dir;\n\t\t}\n\t\tplevel[ich] = level;\n\t\tif (pcls[ich] != BDI_BN)\n\t\t\tpcls[ich] = cls;\n\t}\n\n\treturn ich;\n}\n", "arg_1": {"until": [], "do_sample": true, "temperature": 0.7, "max_gen_toks": 2000}}}, "resps": [["To create a LibFuzzer-style fuzzing harness for the `fz_bidi_resolve_explicit` function, you need to write a function that takes a buffer of arbitrary data and uses it to call `fz_bidi_resolve_explicit`. The harness should be able to handle various input lengths and values, as well as edge cases.\n\nHere's an example of how you can write such a harness:\n\n```c\n#include <stddef.h>\n#include <stdint.h>\n#include <assert.h>\n#include <string.h>\n\n// Define the constants and types used in the function\n#define BIDI_LEVEL_MAX 125\n\ntypedef enum {\n    BDI_N = 0,\n    BDI_L = 1,\n    BDI_R = 2,\n    BDI_AL = 3,\n    BDI_EN = 4,\n    BDI_ES = 5,\n    BDI_ET = 6,\n    BDI_AN = 7,\n    BDI_CS = 8,\n    BDI_BN = 9,\n    BDI_S = 10,\n    BDI_WS = 11,\n    BDI_ON = 12,\n    BDI_LRE = 13,\n    BDI_LRO = 14,\n    BDI_RLE = 15,\n    BDI_RLO = 16,\n    BDI_PDF = 17\n} fz_bidi_chartype;\n\ntypedef uint8_t fz_bidi_level;\n\n// Helper functions used in the original function\nstatic inline fz_bidi_level greater_even(fz_bidi_level level) {\n    return (level + 2) & ~1;\n}\n\nstatic inline fz_bidi_level greater_odd(fz_bidi_level level) {\n    return (level + 1) | 1;\n}\n\n// The function to be fuzzed\nsize_t fz_bidi_resolve_explicit(fz_bidi_level level, fz_bidi_chartype dir, fz_bidi_chartype *pcls, fz_bidi_level *plevel, size_t cch, fz_bidi_level n_nest);\n\n// Fuzzing harness\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {\n    if (Size < 4) return 0; // We need at least 4 bytes: 1 for level, 1 for dir, 1 for n_nest, and at least 1 for the array\n\n    // Extract the first byte as level, second byte as dir, third byte as n_nest\n    fz_bidi_level level = Data[0] % (BIDI_LEVEL_MAX + 1);\n    fz_bidi_chartype dir = static_cast<fz_bidi_chartype>(Data[1] % (BDI_PDF + 1));\n    fz_bidi_level n_nest = Data[2] % (BIDI_LEVEL_MAX + 1);\n\n    // Calculate the number of characters to process\n    size_t cch = Size - 3;\n\n    // Create arrays for pcls and plevel\n    fz_bidi_chartype *pcls = new fz_bidi_chartype[cch];\n    fz_bidi_level *plevel = new fz_bidi_level[cch];\n\n    // Copy the remaining data into pcls\n    memcpy(pcls, Data + 3, cch);\n\n    // Call the function to be fuzzed\n    fz_bidi_resolve_explicit(level, dir, pcls, plevel, cch, n_nest);\n\n    // Clean up\n    delete[] pcls;\n    delete[] plevel;\n\n    return 0; // Non-zero return indicates error in the fuzzer\n}\n```\n\n### Explanation:\n1. **Constants and Types**: The constants and types used in the `fz_bidi_resolve_explicit` function are defined.\n2. **Helper Functions**: The helper functions `greater_even` and `greater_odd` are defined.\n3. **Fuzzing Harness**:\n   - The harness function `LLVMFuzzerTestOneInput` is defined to take a buffer of arbitrary data (`Data`) and its size (`Size`).\n   - It checks if the size is at least 4 bytes to ensure there are enough bytes to extract `level`, `dir`, `n_nest`, and at least one character.\n   - The first three bytes of the buffer are used to determine `level`, `dir`, and `n_nest`.\n   - The remaining bytes are used to fill the `pcls` array.\n   - The `fz_bidi_resolve_explicit` function is called with these parameters.\n   - Memory allocated for `pcls` and `plevel` is cleaned up after the function call.\n\nThis harness will allow LibFuzzer to generate random inputs and test the `fz_bidi_resolve_explicit` function for potential issues."]], "filtered_resps": ["To create a LibFuzzer-style fuzzing harness for the `fz_bidi_resolve_explicit` function, you need to write a function that takes a buffer of arbitrary data and uses it to call `fz_bidi_resolve_explicit`. The harness should be able to handle various input lengths and values, as well as edge cases.\n\nHere's an example of how you can write such a harness:\n\n```c\n#include <stddef.h>\n#include <stdint.h>\n#include <assert.h>\n#include <string.h>\n\n// Define the constants and types used in the function\n#define BIDI_LEVEL_MAX 125\n\ntypedef enum {\n    BDI_N = 0,\n    BDI_L = 1,\n    BDI_R = 2,\n    BDI_AL = 3,\n    BDI_EN = 4,\n    BDI_ES = 5,\n    BDI_ET = 6,\n    BDI_AN = 7,\n    BDI_CS = 8,\n    BDI_BN = 9,\n    BDI_S = 10,\n    BDI_WS = 11,\n    BDI_ON = 12,\n    BDI_LRE = 13,\n    BDI_LRO = 14,\n    BDI_RLE = 15,\n    BDI_RLO = 16,\n    BDI_PDF = 17\n} fz_bidi_chartype;\n\ntypedef uint8_t fz_bidi_level;\n\n// Helper functions used in the original function\nstatic inline fz_bidi_level greater_even(fz_bidi_level level) {\n    return (level + 2) & ~1;\n}\n\nstatic inline fz_bidi_level greater_odd(fz_bidi_level level) {\n    return (level + 1) | 1;\n}\n\n// The function to be fuzzed\nsize_t fz_bidi_resolve_explicit(fz_bidi_level level, fz_bidi_chartype dir, fz_bidi_chartype *pcls, fz_bidi_level *plevel, size_t cch, fz_bidi_level n_nest);\n\n// Fuzzing harness\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {\n    if (Size < 4) return 0; // We need at least 4 bytes: 1 for level, 1 for dir, 1 for n_nest, and at least 1 for the array\n\n    // Extract the first byte as level, second byte as dir, third byte as n_nest\n    fz_bidi_level level = Data[0] % (BIDI_LEVEL_MAX + 1);\n    fz_bidi_chartype dir = static_cast<fz_bidi_chartype>(Data[1] % (BDI_PDF + 1));\n    fz_bidi_level n_nest = Data[2] % (BIDI_LEVEL_MAX + 1);\n\n    // Calculate the number of characters to process\n    size_t cch = Size - 3;\n\n    // Create arrays for pcls and plevel\n    fz_bidi_chartype *pcls = new fz_bidi_chartype[cch];\n    fz_bidi_level *plevel = new fz_bidi_level[cch];\n\n    // Copy the remaining data into pcls\n    memcpy(pcls, Data + 3, cch);\n\n    // Call the function to be fuzzed\n    fz_bidi_resolve_explicit(level, dir, pcls, plevel, cch, n_nest);\n\n    // Clean up\n    delete[] pcls;\n    delete[] plevel;\n\n    return 0; // Non-zero return indicates error in the fuzzer\n}\n```\n\n### Explanation:\n1. **Constants and Types**: The constants and types used in the `fz_bidi_resolve_explicit` function are defined.\n2. **Helper Functions**: The helper functions `greater_even` and `greater_odd` are defined.\n3. **Fuzzing Harness**:\n   - The harness function `LLVMFuzzerTestOneInput` is defined to take a buffer of arbitrary data (`Data`) and its size (`Size`).\n   - It checks if the size is at least 4 bytes to ensure there are enough bytes to extract `level`, `dir`, `n_nest`, and at least one character.\n   - The first three bytes of the buffer are used to determine `level`, `dir`, and `n_nest`.\n   - The remaining bytes are used to fill the `pcls` array.\n   - The `fz_bidi_resolve_explicit` function is called with these parameters.\n   - Memory allocated for `pcls` and `plevel` is cleaned up after the function call.\n\nThis harness will allow LibFuzzer to generate random inputs and test the `fz_bidi_resolve_explicit` function for potential issues."], "filter": "none", "metrics": ["exact_match"], "doc_hash": "6cf2facb709317b3d2c8368adfe834c25bb0ed975ff2b57f8a372229af761dab", "prompt_hash": "572a0551fbd05dfcdca5579e9752ed5033cd4e3623d3a5c10336d1eb2924cd34", "target_hash": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855", "exact_match": 0.0}
